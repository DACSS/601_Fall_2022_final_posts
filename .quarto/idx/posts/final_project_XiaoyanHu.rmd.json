{"title":"Final project: Calculating and visualizing texture profile analysis","markdown":{"yaml":{"title":"Final project: Calculating and visualizing texture profile analysis","author":"Xiaoyan Hu","desription":"data analysis and visualization of lab-made adipose","date":"12/05/2022","format":{"html":{"toc":true,"code-fold":true,"code-copy":true,"code-tools":true,"number-sections":true}},"categories":["food sample"]},"headingText":"Sys.setenv(","containsRefs":false,"markdown":"\n<style>\ndetails {\n    border: 1px solid;\n    border-radius: 10px;\n    padding: .1em .5em 0;\n    text-align: left;\n}\n</style>\n\n---\n\n```{r global_setting, echo = FALSE, message = FALSE, warning = FALSE}\nlibrary(knitr)\n\nopts_chunk$set(\n  message = FALSE,\n  warning = FALSE,\n  comment = NA,\n  echo = T\n)\n#   \"RETICULATE_PYTHON\" = \"C:/Anaconda_Python_3/python.exe\"\n# )\n```\n\n<details>\n```{r load_packages, echo=T}\n#| label: setup\n#| warning: false\n#| message: false\n\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(summarytools)\nlibrary(pracma)\nlibrary(ggplot2)\nlibrary(fmsb)\nlibrary(scales)\nlibrary(plotly)\nlibrary(knitr)\n```\n</details>\n\n\n## Introduction \n  There is a growing demand on plant-based meat analogs due to ethical, environmental and health concerns associated associated with the production of real meat and seafood. Meat and seafood analogs should mimic the desirable appearance, texture, and flavor of the real versions. In this study, we investigated on the texture of animal meat and lab made analogs, especially on their texture profile of adipose tissue(know as fat meat). \n  \n  In this data, I have 5 samples. Control is beef fat.Sample 1-4 composed of different plant-based ingredients such as soybean oil, coconut oil, soybean protein and agar to combine them into a emulsion or gel that looks similar as fat meat under microscope. However, they still have huge differences on the macro texture. \n  \n  Texture profile analysis mimics motion and force in human oral cavity. the measurement including two times of compression and raw data including time and corresponding time. From this data set, many other parameters can be calculated from the graph. The automatic calculation sometimes can be confusing and messy data have to be processed by excels and individual calculations.  \n  \n  Parameter including hardness, adhesiveness, resilience, cohesion and chewiness. The definition and calculation will be introduced in below section. \n\n  In this report, the raw data of texture profile analysis will be tidied and calculated.  The 5 parameter data will be calculated either from raw data or graph and will be visualized. Interpret of comparison in different samples will be performed. Using R may provide an efficient way to process the raw data with better visualization compare to traditional excel plotting and calculation. \n\n## Data \n  Raw TPA data is presented as time versus force. By plotting this graph, further texture parameters can be done by calculation. \n\n### tidy data\n\nIn this section, the raw data was reded in, pivoted and transformed into a new table as previewed below.\n\n```{r read in and pivot}\n#read in data.\n# data1 = Texture Profile analysis of 5 samples including data of each time and force\n# the cell_limits c=(upper left cell), c=(lower right cell)\ndata1<- read_excel(\"_data/final_data.xlsx\",\n                   sheet=\"TPAraw\",\n                  range = cell_limits(c(3,1),c(NA,10)),\n              col_names = c(\"control0time\",\"control0force\",\"S10time\",\"S10force\",\"S20time\",\"S20force\",\"S30time\",\"S30force\",\"S40time\",\"S40force\"))\n\n#generate a row number which will help locate data below\ndata1<-mutate(data1, row_num = seq.int(nrow(data1)))\n                               \n#converting character data into numeric\ninvisible(lapply(data1, as.numeric))\n\n#pivot data into 4 variables\ndata2<-data1%>% pivot_longer(cols = c(control0force,S10force, S20force, S30force,S40force),\n                             names_to = \"sampleforce\",\n                             values_to = \"force1\")%>%\n  separate(sampleforce, into = c(\"sample\", \"type\"), sep = \"0\")\n\n#extract columns needed and form a clean data frame\nTDdata<- data.frame(time = data2$control0time,\n                    force1 = data2$force1,\n                    sample = data2$sample,\n                    row_num = data2$row_num)\n#preview of tidy data\nhead(TDdata)\n\n\n#result_df = TDdata%>%\n # group_by(sample)%>%\n # arrange(time + sample)%>%\n # mutate(force_T1 = lead(force1))%>%\n  \n#filter(force1>0)%>%\n #filter(force_T1 <0)%>%print()\n#df_1 = result_df %>% filter(sample == \"control\")\n#df_2 = result_df %>% filter(sample == \"S1\")\n#df_3 = result_df %>% filter(sample == \"S2\")\n#df_4 = result_df %>% filter(sample == \"S3\")\n#df_5 = result_df %>% filter(sample == \"S4\")\n\n```\n\n</details>\n\n\n### Calculation\n\n  Below is a sample graph of how raw data plotted out as time VS force looks like.\n```{r}\n# In this section, other parameter described above will be calculated\n# Below includes a sample graph\ninclude_graphics(\"_data/TPA1.png\")\n```\n  In the texture profile analysis, the highest point of first peak represents the hardness of the sample.The F1 force is defined as hardness of sample. In below block, a function is written to filter out the maximum force of one sample.  Below table in force column present the highest peak in each sample as the hardness.\n    \n#### find hardness F1\n```{r}\n# Hardness = F1\n# group by sample and filter the sample you want to calculate\n#calculate the cumulative area by time and force in each row, this data will used in later section\n#slice out the maximum force\n#control F1#S1 F1\nf1func<-function(x) {\n  return( TDdata%>%group_by(sample)%>%\n            filter(sample == x)%>%\n  mutate(area1=cumtrapz(time,force1))%>%\n  slice_max(force1))\n}\n\ndf1<-f1func('control')\ndf2<-f1func('S1')\ndf3<-f1func('S2')\ndf4<-f1func('S3')\ndf5<-f1func('S4')\n\n#merge sliced samples into a table\nmergefunc<-function(a,b,c,d,e){\n  return(a %>%full_join(b,by = c(\"time\", \"force1\", \"sample\", \"row_num\", \"area1\"))%>%\n  full_join(c,by = c(\"time\", \"force1\", \"sample\", \"row_num\", \"area1\"))%>% \n  full_join(d,by = c(\"time\", \"force1\", \"sample\", \"row_num\", \"area1\"))%>% \n  full_join(e,by = c(\"time\", \"force1\", \"sample\", \"row_num\", \"area1\")))\n}\nF1<-mergefunc(df1,df2,df3,df4,df5)%>%print()\n\n#TRY <- function(control,max_time,time){\n#  return(TDdata%>%group_by(sample)%>%\n#  filter(sample = 'control')%>%\n#  mutate(area2 = cumtrapz(time,force1))%>%\n # mutate(force_t1 =lead(force1)))%>%\n  #  F1%>%select(force1, sample ,time) %>%\n# rename(max_time = time) %>%\n #right_join(TDdata)%>%\n  # filter(time>max_time)%>%\n  #filter(force1 > 0)%>%\n  #filter(force_t1<0)\n  \n#} \n#TRY(control, max_time, time)\n```\n\nResilience is defined as area b/area and can be understand as how much sample regain after first compression. And calculated as area b/area a.\nTherefore, the next trunk finds out the endpoint of first peak. the cumulative area from end of first peak minus cumulative area of the maximum force(calculated above) will be the area b.\n\n#### find area b    \n```{r}\n#function to find the endpoint of peak 1 is wroted as finding the first time point after F1 that cooresponding force cross 0. \n#lead function align the force in next time point, therefore, the first point where force+1 is negative, and force is positive, implies the first point cross 0, which is the first peak end point. \n\n#endpoint of first peak\nendfunc<-function(x, y){\n  return(TDdata%>%group_by(sample)%>%\n  filter(sample == x)%>%\n  mutate(area2 = cumtrapz(time,force1))%>%\n  filter(row_num > y)%>%\n  mutate(force_t1 =lead(force1))%>%\n  filter(force1 > 0)%>%\n  filter(force_t1<0)%>%\n  slice(1))\n}\n\ndf6<-endfunc('control', 470)\n\ndf7<-endfunc('S1', 227)\n\ndf8<-endfunc('S2', 230)\n  \ndf9<-endfunc('S3',424)\n\ndf10<-endfunc('S4', 212)\n\n#merge sliced samples into a table\nmergefunc2<-function(a,b,c,d,e){\n  return(a %>%full_join(b,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area2\",\"force_t1\"))%>%\n  full_join(c,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area2\",\"force_t1\"))%>% \n  full_join(d,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area2\",\"force_t1\"))%>% \n  full_join(e,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area2\",\"force_t1\")))\n}\nEND1<-mergefunc2(df6,df7,df8,df9, df10)\n\n#area b is calculated by cumulative area at end point minus cumulative area at F1\nareab = F1 %>% full_join(END1,by = c( \"sample\"))%>%mutate(areab =  area2 -area1)\n```\nThe cohesion stands for How well the product withstands a second deformation relative to its resistance under the first deformation an calculated as area (d+e)/(a+b). Therefore, we still need to find the start and end point of peak 2. \n\nIn this section, similar functions were wrote to finding the function. The data was cutted after endpoint 1 to find the maximum which is the F2.\n\n#### find F2\n```{r}\n#finding F2 by filtering the sample after the first peak and then slice tha maximum\nF2func<-function(x,y){\n  return(TDdata%>%group_by(sample)%>%\n  filter(sample == x)%>%\n   mutate(area1 = cumtrapz(time,force1))%>%\n  filter(row_num > y)%>%\n  slice_max(force1))\n}\ndf11<-F2func('control', 551)\n\ndf12<-F2func('S1', 259)\n\ndf13<-F2func('S2', 268)\n   \ndf14<-F2func('S3', 587)\n  \ndf15<-F2func('S4', 320)\n  \nF2<- mergefunc(df11, df12, df13, df14, df15)\n```\nThe start point of second peak was filtered back to find the cross 0 point. And the end point is also selected by the cross 0 point after F2.\n\n#### find the start point of area d\n```{r }\n#find the start point of area d\nstart2<-function(x,y){\n  return(TDdata%>%group_by(sample)%>%\n  filter(sample == x)%>%\n  mutate(area3 = cumtrapz(time,force1))%>%\n  filter(row_num < y)%>%\n  arrange(desc(row_num))%>%\n   mutate(force_t1 =lead(force1))%>%\n  filter(force1 > 0)%>%\n  filter(force_t1<0)%>%\n  slice(1))\n}\ndfd1<-start2('control', 3408)\ndfd2<-start2('S1', 2681)\ndfd3<-start2('S2', 2688)\ndfd4<-start2('S3', 3270)\ndfd5<-start2('S4', 2631)\n\nmergefunc3<-function(a,b,c,d,e){\n  return(a %>%full_join(b,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area3\",\"force_t1\"))%>%\n  full_join(c,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area3\",\"force_t1\"))%>% \n  full_join(d,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area3\",\"force_t1\"))%>% \n  full_join(e,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area3\",\"force_t1\")))\n}\n\nstart2<-mergefunc3(dfd1, dfd2,dfd3,dfd4,dfd5)\n```\n\n#### find the ending point of area e\n```{r}\n#find the ending point of area e\nEND2func<-function(x, y){\n  return(TDdata%>%group_by(sample)%>%\n  filter(sample == x)%>%\n  mutate(area4 = cumtrapz(time,force1))%>%  \n  filter(row_num >y)%>%\n  mutate(force_t1 =lead(force1))%>%\n  filter(force1 > 0)%>%\n  filter(force_t1<0)%>%\n  slice(1))\n}\ndfd6<-END2func('control',3408)\ndfd7<-END2func('S1',2681)\ndfd8<-END2func('S2',2688)\ndfd9<-END2func('S3',3270)\ndfd10<-END2func('S4',2631)\n\nmergefunc4<-function(a,b,c,d,e){\n  return(a %>%full_join(b,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area4\",\"force_t1\"))%>%\n  full_join(c,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area4\",\"force_t1\"))%>% \n  full_join(d,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area4\",\"force_t1\"))%>% \n  full_join(e,by = c(\"time\", \"force1\", \"sample\", \"row_num\",\"area4\",\"force_t1\")))\n}\n\nEND2<-mergefunc4(dfd6,dfd7,dfd8,dfd9,dfd10)\n\nareae = F2 %>% full_join(END2,by = c( \"sample\"))%>%mutate(areae =  area4 -area1)\naread = F2 %>% full_join(start2,by = c( \"sample\"))%>%mutate(aread =  area1 -area3)\n```\n\n Springiness is defined as how a product physically springs back at the second compression.\n    \nTherefore, the critical point we need to find out from the data is the coordinate of F1, the time where area b ends, F2, and where the second peak starts and ends. After obtaining these data, the calculation can be performed.\n    \n#### combine all calculated value into a data frame for visualization\n```{r}\n# all value calculated above are sorted into a new table\n# Gumminess = Hardness*cohesion\n# Chewiness = Gumminess * Springiness\n\nparameters<- data.frame(sample_name = F1$sample,\n                        hardness = F1$force1,\n                       resilience = c(areab$area2-areab$area1),\n                       cohesion = c((aread$aread +areae$areae) / (F1$area1 +areab$areab)),\n                        springiness = c((F2$time-start2$time)/F1$time))\nparameters<-parameters%>%mutate(chewiness = parameters$hardness * parameters$cohesion)%>%print()\n\n```\n\n## Visualizition\nIn texture analysis, comparing the values sometimes can be difficult to interpret the data. By visualizing, we can easily compare the single parameters in each sample and analysis how the material brings the strength and weakness separately. We can also compare the overall similarity of each sample to the control ro select a good candidate to continue research on. \n\n### overview of raw data\nBelow is an overview of all five samples. As we can see, all the parameters were calculated from this graph. \n* Put your cursor on graph to see data points\n```{r}\np_force = ggplot(data = TDdata) + \n  geom_line(mapping = aes(x = time, y = force1, color = sample)) +\n  labs(title = \"force v.s. time\")\np_force %>% ggplotly()\n```\n\n### hardness\n\nAll the parameters was plotted in bar chart first to compare each single parameter individually. This helps understand the specific strength of each material. \nControl which is the beef sample shows good hardness implies the inner structure of beef provide a good support to the over all material. The lab created samples we can see that emulsion samples(S1 and S3) are less hard than gelled samples(S2 and S4) while solid coconut oil under room temperature(S3 and S4) are better than liquid soybean oil(S1 and S2)\n```{r}\n#bar chart need to include stat='identity‘ which is basically telling ggplot2 you will provide the y-values for the barplot, rather than counting the aggregate number of rows for each x value, which is the default stat=count\nggplot(parameters, aes(x= sample_name, y= hardness, fill = hardness)) +\n    geom_bar(stat='identity',colour = 'black') + \n  scale_y_log10() +\n  labs(title = 'Hardness')+ \n  scale_color_gradient(low = \"royalblue\", high = \"steelblue\")\n```\n### resilience\nResilience is how much the sample bounce back from the first compression. Still, the control sample raise most. And the soybean gelled emulsion (S3) remains highest. This indicates the liquid oil gives the best recovery to the gelling agent.\n```{r}\n\nggplot(parameters, aes(x= sample_name, y= resilience,fill = resilience)) +\n    geom_bar(stat='identity',colour = 'black') + scale_y_log10()+ labs(title = 'Resilience')+ scale_fill_gradient(low = \"hotpink3\", high = \"lightpink\")\n```\n### cohesion\nThe cohesion measure how the sample stand at second compression, which can be understand as how much hardness remains in second compression. Some brittle sample may broke during this time. From the graph we can easily tell, emulsion samples (S1S3) have relative high cohesion under second compress. \n```{r}\nggplot(parameters, aes(x= sample_name, y= cohesion, fill = cohesion)) +\n    geom_bar(stat='identity',colour = 'black') + labs(title = 'Cohesion') + scale_fill_gradient(low = \"turquoise4\", high = \"steelblue1\") \n\n```\n### spinginess\nThe springiness indicate the relative time sample bounce back. There was no significant differenceb between each samples. \n```{r}\nggplot(parameters, aes(x= sample_name, y= springiness, fill = springiness)) +\n    geom_bar(stat='identity',colour = 'black')  +\n  labs(title = 'Springiness')+ \n  scale_fill_gradient(low = \"cadetblue4\", high = \"cadetblue1\")\n```\n### chewiness\nThe chewiness expresses the overall behavior of second compression. Here we can see, our control have the relatively high chewiness while samples are gradually gaining chewiness by adding factors such as solid oil and gelling agent. \n```{r}\nggplot(parameters, aes(x= sample_name, y= chewiness, fill = chewiness)) +\n    geom_bar(stat='identity',colour = 'black') +  scale_y_log10 ()+ labs(title = 'chewiness')+ scale_fill_gradient(low = \"mediumorchid4\", high = \"plum\")\n```\n### overall comparison\nThe radar chart gives a better idea of overall balance overall samples. From the radar chart, we can easily understandthe control still have strength over power all lab-made samples, especially when some parameters were plotted in log scale. However, between samples, we can also differenciate that overall S3 and S4 have a similar area than S1 and S2. This indicates the solid fat contributes more to the fat structure instead of the gelling agent (S3,S4 is overall better than S1,S2). Also looking at S1 and S2, gelling agent provide much improvement  while did not work in S3 and S4. The solid oil somehow restricted the impovement of gelling agent. Overall, S3 and S4 performed best and overall close the character of control. \n```{r}\nmax<-c('max',25000, 4000, 1,1,15000)\nmin<-c('min',10,10,0,0.5,10)\nparameters1<-rbind(c = min, c=max, parameters, deparse.level = 0)\nparameter2<- transform(parameters1, \n          hardness = as.numeric(hardness),\n          resilience = as.numeric(resilience),\n          cohesion = as.numeric(cohesion),\n          springiness = as.numeric(springiness),\n          chewiness = as.numeric(chewiness))\n\nparameters3<-parameter2%>%\n  mutate(hardnesslog = log10(hardness))%>%\n  mutate(chewinesslog = log10(chewiness))%>%\n  mutate(resiliencelog = log10(resilience))\nparameters3<-parameters3[-c(1:3,6)]\n  radarchart(parameters3,maxmin = FALSE,cglwd = 0.5,\n             pcol  = c(\"white\",\"white\",\"blue\",\"pink4\",\"orchid\",\"turquoise3\",\"yellow\"),\n             plty = 1,palcex = 5,\n              pfcol =  scales::alpha(c(\"white\",\"white\",\"blue\",\"pink4\",\"orchid\",\"turquoise3\",\"yellow\"),0.2))\n            \n    legend(x = \"right\",\n                    legend = c(\"control\",\"S1\",\"S2\",\"S3\",\"S4\") ,\n           fill = c(\"blue\",\"pink4\",\"orchid\",\"turquoise3\",\"gold\")\n                    )\n```\n\n\n## Reflection\n\n### Why I choose this project\n\nIn this project, I selected a measurement data that we used daily in our lab. I want to chose this data because the machine can calculate the value, however sometime with mistakes. In this case, we have to import the data into excel, plot it, find value we need among thousands of data point and then calculate. This process is boring and redunant. By learning r, I found it might be a food idea that I can find a easier way to calculated all this value automatically to avoid human labor. And by the time this programming works, the future data can be imported, organized and visualized automatically which can save much time. Therefore, I decided to work on this project. \n\n### Difficultes I met\n\nBy looking at others projects and examples in the class, I found most of them are aiming at visualization and analysis. However, in my case, the most heavy work was in calculation. The raw data was simple and easy to tidy, however, finding the significant values in this data requires a lot of work. The measurements were human tested samples and there are many interference data points. For example, I want to find the end point of the first peak, where force = 0. However, how would I select the point since the nears point to 0 may be 10, and the next wil be -10, where 0 doesn't actually have a physically point. In this case, I have to using functions to filter and understand where the value I want exactly and not taking in those interference points. \n\nAlso, reducing the redundant steps has also been a difficulty for me to solve. By learning functions, I found that repeated steps can be easily archieved by some package or functions.\n\n  Another thing I have learnt from this class and this project is how to brainstorm the steps that you reach to your final goals. My data looks like a simple data set but considering the interference, it became very difficult to make it accurate. More and more steps were added when i wrote the code and repeat and reduced. So there are tons of effort which may not been present in the code. The learning process was really interesting but tiring, with understanding varies packages and functions. The accumulation will make the future coding much more easier. \n  \n### Next step of this project\n\nI haven't optimized the calculation into a best, easiest and shortest steps to calculate all the values which can be done in the future. Another problem I left was indexing of table into tables. This code may be simplified without writing functions and creating much tables. \n\nAlso, there might be a way to cooperate the sample ingredients into data presenting. However, most of my work was done in descriptions. It may also be difficult to visualize or make those numeric to consider about the ingredients.This could also be innovative in presenting scientific research results to help other understand. \n\n\n\n## Conclusion\n\nIn conclusion, this project calculated the value of texture analysis profile and visualized the data to compare the samples. This helps us to understant the single parameter and overall strenght and weakness of each sample and find the most close lab-made sample to our control. \n\nIn terms of R, this project help me helps me build up idea of how to approach data in a desired manner and how to make the coding easy and simple. Althought I haven't make it perfect in this project, it is a really great process to learn the idea with processing data. \n\n## Bibliography\n\n1) Hu, X. and D. J. McClements (2022). \"Construction of plant-based adipose tissue using high internal phase emulsions and emulsion gels.\" Innovative Food Science & Emerging Technologies 78: 103016.\n2) Centre for Indutrial, R. (2022). Texture Analysis And Texture Profile Analysis - Rheology Lab.\n3)Wickham, H. and G. Grolemund (2016). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data, O'Reilly Media.\n\t\n\n\t\n\n\t\n\n \n\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":true,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"output-file":"final_project_XiaoyanHu.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.37","execution":{"freeze":"auto"},"smooth-scroll":true,"page-layout":"full","mainfont":"Open Sans","linkcolor":"#881c1c","theme":{"light":["flatly","../styles.scss"],"dark":["darkly","../styles.scss"]},"comments":{"giscus":{"repo":"DACSS/601_Fall_2022","category":"Announcements"}},"toc-location":"right","search":true,"title":"Final project: Calculating and visualizing texture profile analysis","author":"Xiaoyan Hu","desription":"data analysis and visualization of lab-made adipose","date":"12/05/2022","categories":["food sample"],"code-copy":true},"extensions":{"book":{"multiFile":true}}}}}